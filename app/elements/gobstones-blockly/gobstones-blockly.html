<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/gs-element-blockly/gs-element-blockly.html">
<link rel="import" href="../../scripts/parser.html">
<link rel="import" href="../../scripts/behaviors/busListenerBehavior.html">
<link rel="import" href="../../scripts/jquery.html">
<link rel="import" href="../../scripts/stylist.html">

<dom-module id="gobstones-blockly">
  <template>

    <style>
      :host {
        display: block;
        height: 100vh;
      }
    </style>

    <gs-element-blockly id="blockly" class="blockly" workspace-xml="{{workspaceXml}}" toolbox="{{toolbox}}"></gs-element-blockly>
    <gs-element-blockly id="blocklytmp" style="visibility: hidden"></gs-element-blockly>
  </template>

  <script>

    Polymer({
      is: "gobstones-blockly",
      behaviors: [
        Polymer.BusListenerBehavior
      ],
      properties: {
        mode: {
          type: String,
          value: "main"
        },
        code: {
          type: Object,
          value: { main: "", library: "", teacher: "" },
          observer: "setAsDirty"
        },
        toolbox: Object,
        workspace: {
          type: Object,
          value: { main: "", library: "" }
        },
        workspaceXml: {
          type: String,
          observer: "_updateCode"
        },

        libraryProcedures: Array,
        libraryFunctions: Array
      },

      ready: function() {
        const boardsPanel = document.getElementById("boards");
        if (boardsPanel) {
          this.runner = boardsPanel.$.runner;
          this.runner.addEventListener("run", ({ detail }) => {
            this._onRunRequest(detail)
          });
          this.runner.addEventListener("cancel", () => {
            window.BUS.fire("cancel-request");
          });
        }

        this.subscribeTo("initial-state", event => {
          this._runCode(event);
        });

        this.stylist = new Stylist();
        this.stylist.setBlocklyResize();

        setTimeout(() => {
          if (window.LOAD_PENDING_PROJECT) {
            window.LOAD_PENDING_PROJECT()
            window.LOAD_PENDING_PROJECT = undefined;
          }
        }, 0);

        window.blockly = this.$.blockly; // TODO: Es para debuggear
      },

      addCode: function(xml) {
        this.$.blockly.appendBlocksToWorkspace(xml);
      },

      setCode: function(code, mode = "main") {
        this.workspace[mode] = code;
        this.code[mode] = mode === "teacher" ? code : this._xmlToCode(code);
        if (this.mode === mode) this.workspaceXml = code;

        if (mode === "teacher") {
          this._onTeacherLibraryChange(code);
        }
      },

      toggleMode: function() {
        if (this.mode === "library" && this.libraryHasErrors)
          window.BUS.fire("compilation-error", { libraryHasErrors: true });

        this._setMode(
          this.mode === "main" ? "library" : "main"
        );
      },

      setAsDirty: function() {
        window.BUS.fire("editor-dirty");
      },

      reset: function() {
        this._setMode("main");
        this.setCode(this.EMPTY_WORKSPACE, "main");
        this.setCode("", "library");
        this.setCode("", "teacher");
        this.toolbox = null;
        this.$.blockly.primitiveProcedures = [];
        this.$.blockly.primitiveFunctions = [];
      },

      _onRunRequest: function(options) {
        this._setMode("main");
        window.BUS.fire("run-request", options);
      },

      _runCode: function(initialState) {
        const code = this.code;
        this._onTeacherLibraryChange(code.teacher);

        console.info("GENERATED CODE", code);
        try {
          this.runner.run(
            { initialState, code },
            (error, code) => {
              let line = _.trim(code[error.location.mode].split("\n")[error.location.line]);
              window.BUS.fire("compilation-error", { error, line });
            },
            (state) => this._notify(state)
          );
        } catch (e) {
          window.BUS.fire("unknown-error", e);
          console.error("---UNKNOWN ERROR---");
          throw e;
        }
      },

      _notify: function(state) {
        if (state.error) {
          window.BUS.fire("execution-error", state.error.message);
        } else
          window.BUS.fire("execution-result", { board: state });
      },

      _setMode: function(mode) {
        this.mode = mode;
        window.BUS.fire("mode-change", this.mode);
        this.workspaceXml = this._getWorkspace()[this.mode];

        // TODO: Enviar a libraryProcedures y libraryFunctions
        // Ver bien en quÃ© formato mandarlos. Propuesta: "PonerBolitasEn(color,direccion)"
        // https://github.com/Program-AR/gs-element-blockly/issues/50#issuecomment-280254981

        // this.$.blockly.primitiveProcedures = mode === "main" ? this.libraryProcedures : [];
        // this.$.blockly.primitiveProcedures = mode === "main" ? this.libraryFunctions : [];
      },

      _updateCode: function() {
        if (!this.EMPTY_WORKSPACE)
          this.EMPTY_WORKSPACE = this.workspaceXml;

        if (this.runner) this.runner.stop()
        this._getWorkspace()[this.mode] = this.workspaceXml;
        this.code[this.mode] = this.$.blockly.generateCode();

        if (this.mode === "library") this._updateLibraryActions();
      },

      _onTeacherLibraryChange: function(teacher) {
        try {
          const actions = this._getActionNames(teacher);

          if (!_.isEmpty(actions.procedureNames)) {
            this.$.blockly.primitiveProcedures = actions.procedureNames;
            this.$.blockly.primitiveFunctions = actions.functionNames;
          }
        } catch(e) {
          this.runner.reportTeacherLibraryErrors(e);
        }
      },

      _updateLibraryActions: function() {
        try {
          const actions = this._getActions(this.code.library);

          this.libraryProcedures = actions.procedureDeclarations;
          this.libraryFunctions = actions.functionDeclarations;
          this.libraryHasErrors = false;
        } catch(e) {
          // it does not compile
          this.libraryHasErrors = true;
        }
      },

      _getActions: function(sourceCode) {
        const declarations = new Parser().parse(sourceCode).declarations;
        const withAlias = (alias) => (declaration) => declaration.alias === `${alias}Declaration`;

        const computeDeclarations = (alias) => _.filter(declarations, withAlias(alias))

        return {
          procedureDeclarations: computeDeclarations("procedure"),
          functionDeclarations: computeDeclarations("function")
        };
      },

      _getActionNames: function(sourceCode) {
        const declarations = this._getActions(sourceCode);
        const isAuxiliaryDeclaration = (declaration) => declaration.name.toLowerCase().startsWith("aux");

        const computeDeclarations = (type) =>
          _(declarations[`${type}Declarations`])
          .reject(isAuxiliaryDeclaration)
          .map("name")
          .value();

        return {
          procedureNames: computeDeclarations("procedure"),
          functionNames: computeDeclarations("function")
        };
      },

      _getWorkspace: function() {
        return this.workspace || {};
      },

      _xmlToCode: function(xml) {
        this.$.blocklytmp.workspaceXml = xml;
        return this.$.blocklytmp.generateCode();
      }
    });

  </script>
</dom-module>
